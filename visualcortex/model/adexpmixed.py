__author__ = 'Robert Meyer'


from numba import njit
import numpy as np

from visualcortex.model.utils import check_matrix_and_delay, convert_matrix_jit, \
    create_inputs, reduce_afferent_spiketimes, roll_inputs


class AdexpNetwork(object):
    """ Network model of two ADEXP populations (excitatory "exc" and inhibitory "inh") of neurons.

    Populations can be interconnected via bi-exponential synapses
    and are fed with afferent spikes or an input current.

    In the following the parameters are described that can be set via the `add` function.

    Parameters can be specified in two different flavours, a long and a short description.
    The long description is given by a tuple of two strings first determining the domain of the
    parameter and, secondly, the name itself, e.g. ("aff2exc_synapses", "E_syn") or
    ("exc_neurons","a").
    A short description is based on the parameter name followed by and underscore and
    two indices, the examples
    from above can be abbreviated as "E_syn_EA" (first index the target population, second
    index the source population) and "a_E", respectively.
    Parameters in long descritpion form can be passed to the add function as a part of
    a dicitonary e.g.

    ``net.add({("aff2exc_synapses", "E_syn") : 0.0, ("exc_neurons", "a") : 4.0})``

    or directly in short form as keyword arguments, e.g.

    ``net.add(E_syn_EA=0.0, a_E=4.0)``

    Some parameters are not part of synapses and neurons, and therefore are passed a single
    strings, e.g.

    ``net.add({"dt" : 0.0001})`` or ``net.add(dt=0.0001)``

    All parameters can be inspected via the `parameters` or `short_parameters` attribute of
    the network object.
    Setting parameters via these attributes is not recommended, please use the `add` function
    to set parameters or pass paremeters as a dictionary on network creation.

    Note that NOT all parameters need to be set in order to run a simulation.
    Some parameters like `"mat_tuple"` are actually generated by the network itself
    and are kept in the `parameters` attribute in case the network is rerun
    to avoid recomputation.

    The following parametes do not belong to a neuron population or synapses and define
    the simulation itself.

        dt:

            The stepsize of the simulation in seconds, the width of the Euler Integration

        sample_dt:

            Stepsize with which traces like voltage and currents are recorded,
            pleas use a multiple of dt, e.g. dt = 0.0001 sample_dt = 0.0005.

        duration:

            Duration of one simulation run in seconds, e.g. duration = 1.0

        current_time:

            Current time of simulation, assumed to be 0 if not set. In case the network
            is run several times the current time is automatically increased for
            smooth consecutive simulations.

        exp_steps:

            Number of steps for the approximation of the exponential function of the
            adexp network. In order to save time, exponential values ar pre-computed.
            Intermediate steps are NOT interpolated, simply the nearest neighbor is chosen.
            For large values `exp_steps ~ 10000000` this should be no problem, since
            the error should be only marginal compared to the error due to Euler integration.

        min_value_exp (max_value_exp):

            The minimum (maximum) value for which the exponetial is pre-computed. If none is
            specified, the minimum between inhibitory reversal potential and leak potential
            plus 25% [to account for potential crossings of the membrane potential due to strong
            noise in the input current]
            (the maximum between spike threshold and exponential threshold) are taken.

        max_delay:

            The maximum potential delay that can be observed in the network (due to synapses
            or refractory periods). Can be manually set, but the network is happy to
            infer this value from the synapses and refractory periods itself.

        sample_offset:

            Computed by the network itself in case the network is run several times to
            account for offsets in sampling. Please do NOT set yourself.

        delay_offset:

            Computed by the network itself in case the network is run several times
            to acoount for offstes in delays in between runs. Please do NOT set yourself.


    The following neuron parameters exist for inhibitory ("inh_neurons")
    as well as excitatory neurons ("exc_neurons").

        N:

            Number of neurons of a particular population. If not set, it is inferred from
            the initial conditions.

        V:

            Array of initial conditions of the membrane potential, please make sure
            that ``len(V)==N``.

        w:

            Array of initial conditions of the adaptation variable, similar to the above.

        C:

            Capacitance of neurons (scalar)

        EL:

            Leak potential (scalar)

        gL:

            Leak conductance (scalar)

        a:

            Spike frequency adaptation parameter (scalar)

        b:

            Subtrheshold adaptation parameter (scalar)

        tau_w:

            Adaptation time constant (scalar)

        tau_refr

            Refractory period (scalar)

        Vth:

            Spiking threshold or cut off (scalar)

        VT:

            Threshold parameter of exponential function (scalar)

        Vr:

            Reset potential (scalar)

        DeltaT:

            Slope factor of exponential function (scalar)

        I_aff_bias:

            Input current, either scalar, array of length of number of neurons or
            matrix with as many entries as simulation steps
            ``steps = np.rint(duration/dt).astype(int)`` for a current value for each time
            step.

        sample:

            Array with indices from which neurons to recored current and voltage traces.
            If not specified, traces of all neurons are recorded.

        sample_spikes:

            Array with indices from which neurons to record the spike times.
            If not specified all spikes are recorded.

        maxrate:

            Maximum expected firing rate. Important to pre-allocate memory for
            spike recording. If not specified maximum rate is computed as
            the inverse of the refractory period. Pick a smaller rate to save memory, but
            simulation will crash if more spikes are produced during a simulation run than
            expected by the maxrate parameter.

        refractory:

            Initial conditions for the refractory periods. Array of ints (i.e. multiples of
            dt). You are NOT advised to set this value. Initially it is assumed, that no
            neuron is currently undergoing it's refractory period. The network will rely
            on these settings for consecutive runs.


    The following parameters can be set for every synapse "exc2exc_synapses", "inh2exc_synapses",
    "exc2inh_synapses", "inh2inh_synapses", "aff2exc_synapses", "aff2inh_synapses".

        S:

            Sparse matrix of connection weights, please use a `csr` matrix for performance reasons.
            Rows specify presynaptic and columns post-synaptic neurons.

        S_delay:

            Sparse matrix of delays, as above. If not specified, delays are assumed to last only
            a single timestep `dt`.

        tau_rise:

            Time constant of exponential condutance rise in case of presynaptic spike (scalar).

        tau_decay:

            Decay constant (scalar)

        E_syn;

            Reversal potantial of synapses (scalar)

        g:

            Initial conditions of conductances (array). If not specified
            they are assumed to be 0.

        h:

            Initial conditions of rising phase of conductance (array).  If not specified
            they are assumed to be 0.

        I:

            Initial conditions of currents (array). If not specified
            they are assumed to be 0.

        mat_tuple:

            Converted sparse matrix for numba. This is automatically computed by the
            network from `S` and `S_delay`. Nonetheless, can be performed manually
            with the `convert_matrix_jit` in the utils module.

        input:

            Automatically generated 2D array of delayed inputs. Do NOT set by hand.

    The "aff2exc_synapses" and the "aff2inh_synapses" allow fot one additional parameter:

        spikes:

        Input spikes to neuron population. Specify as 2D array where the first column specifies
        the index of the afferent input (i.e. the row in the weight matrix) and the second
        column the spike time. The 2D array MUST BE SORTED in order of the spike times! This
        is VERY,VERY important, otherwise afferent spikes might be lost.

        For example:

        ``spikes_EA = np.array([[4, 0.002], [16, 0.0034], [4, 0.5], [0, 0.51]])``


    Running the network via the `run` function will gather results in the
    `results` and `short_results` attribute. Naming applies as above.
    The following results can be gathered.

        times:

            Array of the simualtion times

        sample_times:

            Array of times traces were sampled

        current_time:

            Time at the end of the simulation

    For the the "exc_neurons" as well as the "inh_neurons" the following results are provided

        V:

            2D array of voltage traces (which ones to record are specified via the `samples`
            parameter)

        w:

            2D array of adaptation variable traces

        spikes:

            2D array of spiketimes. First column specifies neuron index, second
            the time of the spike analog to the afferent spikes from above.
            2D array is sorted according to the spike times.

        V_mean:

            Mean values of membrane potential for all neurons

        w_mean:

            Mean values of the adaptation value for all neurons

    For all synapses the following results are provided

        I:

            2D array of sampled current traces

        g:

            2D array of sampled conductance traces

        I_mean:

            Mean value of current for all neurons

        g_mean:

            Mean value fo conductance for all neurons




    """

    def __init__(self, parameters=None):
        self.parameters = {} # The parameters
        self.short_parameters = {} # The parameters in short form
        self.results = {} # The results
        self.short_results = {} # The results in short form

        self._simulation_parameters=(
            'dt',
            'sample_dt',
            'current_time',
            'exp_steps',
            'precomputed_exp',
            'min_value_exp',
            'max_value_exp',
            'duration',
            'sample_offset',
            'delay_offset',
            'max_delay',
            # 'noise_seed',
        )

        self._neuron_parameters=(
            'N',
            'V',
            'w',
            'C',
            'EL',
            'gL',
            # 'D',
            'a',
            'b',
            'tau_w',
            'I_Aff_bias',
            'tau_refr',
            'Vth',
            'VT',
            'Vr',
            'DeltaT',
            'sample',
            'sample_spikes',
            'maxrate',
            'refractory',
        )

        self._exc_synapses_parameters = (
            'g_AMPA',
            'g_NMDA',
            'h_NMDA',
            'share_AMPA',
            'tau_decay_AMPA',
            'tau_decay_NMDA',
            'tau_rise_NMDA',
        )

        self._inh_synapses_parameter = (
            'g',
            'tau_decay',
        )

        self._synapse_parameters=(
            'S',
            'E_syn',
            'S_delay',
            'mat_tuple',
            'I',
            'input'
        )


        self._afferent_synapse_parameters=(
            'spikes',
        )

        self.all_parameter_names = []
        self.all_short_parameter_names = []

        self.all_parameter_names.extend(self._simulation_parameters)
        self.all_short_parameter_names.extend(self._simulation_parameters)
        for neuron_name, short in (('exc_neurons', 'E'), ('inh_neurons', 'I')):
            for param in self._neuron_parameters:
                self.all_parameter_names.append((neuron_name, param))
                self.all_short_parameter_names.append(param+'_'+short)

        for synapse_name, short in (('exc2exc_synapses', 'EE'), ('inh2exc_synapses', 'EI'),
                                    ('exc2inh_synapses','IE'), ('inh2inh_synapses', 'II'),
                                    ('aff2exc_synapses', 'EA'), ('aff2inh_synapses', 'IA')):
            for param in self._synapse_parameters:
                self.all_parameter_names.append((synapse_name, param))
                self.all_short_parameter_names.append(param+'_'+short)
            if 'A' in short:
                self.all_parameter_names.append((synapse_name, 'spikes'))
                self.all_short_parameter_names.append('spikes_'+short)
            if short.endswith('E') or short.endswith('A'):
                for param in self._exc_synapses_parameters:
                    self.all_parameter_names.append((synapse_name, param))
                    self.all_short_parameter_names.append(param+'_'+short)
            elif short.endswith('I'):
                for param in self._inh_synapses_parameter:
                    self.all_parameter_names.append((synapse_name, param))
                    self.all_short_parameter_names.append(param+'_'+short)

        self.all_short_parameter_names = tuple(self.all_short_parameter_names)
        self.all_parameter_names = tuple(self.all_parameter_names)

        if parameters is None:
            parameters={}

        self.add(parameters)

    def add(self, *posparameters, **parameters):
        """Adds parameters to the network.

        Either pass a dictonary of parameters, or short parameter names
        as keyword arguments.
        """
        if 'parameters' in parameters:
            parameters.extend(parameters.pop('parameters'))

        if len(posparameters) == 1:
            parameters.update(posparameters[0])
        elif len(posparameters) > 1:
            raise ValueError('You can only pass a single parameter dictionary')

        self._convert_and_check_parameters(parameters)
        self.parameters.update(parameters)
        self.short_parameters = self._produce_short_dict(self.parameters)

    def _convert_and_check_parameters(self, parameters):
        key_list = list(parameters.keys())

        for key in key_list:

            if isinstance(key, tuple):
                continue

            neuron_suffix = key[-2:]
            synapse_suffix = key[-3:]
            if neuron_suffix in ('_E', '_I', '_X'):
                short_key = key[:-2]

                if neuron_suffix == '_E':
                    neurons='exc'
                elif neuron_suffix == '_I':
                    neurons='inh'
                elif neuron_suffix == '_X':
                    neurons='all'
                parameters[(neurons+'_neurons', short_key)]=parameters.pop(key)

            elif synapse_suffix in ('_EE', '_EI', '_IE', '_II', '_EA', '_IA',
                                    '_XE', '_XI', '_EX', '_IX', '_XA','_XX'):
                short_key = key[:-3]

                if synapse_suffix[1] == 'E':
                    target = 'exc'
                elif synapse_suffix[1] == 'I':
                    target = 'inh'
                elif synapse_suffix[1] == 'X':
                    target = 'all'

                if synapse_suffix[2] == 'E':
                    source = 'exc'
                elif synapse_suffix[2] == 'I':
                    source = 'inh'
                elif synapse_suffix[2] == 'A':
                    source = 'aff'
                elif synapse_suffix[2] == 'X':
                    source = 'all'

                synapse_name = source+'2'+target+'_synapses'
                parameters[(synapse_name, short_key)] = parameters.pop(key)


        key_list = list(parameters.keys())

        for key in key_list:
            if isinstance(key, tuple):
                where = key[0]
                what = key[1]

                if where in ('exc_neurons', 'inh_neurons', 'all_neurons'):

                    if where == 'all_neurons':
                        value = parameters.pop(key)
                        parameters[('exc_neurons', what)] = value
                        parameters[('inh_neurons', what)] = value

                elif where in ('exc2exc_synapses', 'inh2exc_synapses', 'exc2inh_synapses',
                             'inh2inh_synapses', 'aff2exc_synapses', 'aff2inh_synapses',
                             'all2exc_synapses', 'all2inh_synapses', 'exc2all_synapses',
                             'inh2all_synapses', 'aff2all_synapses', 'all2all_synapses'):
                    value = None
                    if where == 'all2exc_synapses' or where == 'all2all_synapses':
                        value = parameters.pop(key)
                        parameters[('exc2exc_synapses', what)] = value
                        parameters[('inh2exc_synapses', what)] = value
                        parameters[('aff2exc_synapses', what)] = value
                    if where == 'all2inh_synapses' or where == 'all2all_synapses':
                        if value is None:
                            value = parameters.pop(key)
                        parameters[('exc2inh_synapses', what)] = value
                        parameters[('inh2inh_synapses', what)] = value
                        parameters[('aff2inh_synapses', what)] = value
                    elif where == 'exc2all_synapses':
                        value = parameters.pop(key)
                        parameters[('exc2exc_synapses', what)] = value
                        parameters[('exc2inh_synapses', what)] = value
                    elif where == 'inh2all_synapses':
                        value = parameters.pop(key)
                        parameters[('inh2exc_synapses', what)] = value
                        parameters[('inh2inh_synapses', what)] = value
                    elif where == 'aff2all_synapses':
                        value = parameters.pop(key)
                        parameters[('aff2exc_synapses', what)] = value
                        parameters[('aff2inh_synapses', what)] = value

                else:
                    raise RuntimeError('Something is wrong, %s is not a valid identifier!' % where)

        for key in parameters.keys():
            if not key in self.all_parameter_names:
                raise KeyError('ERROR: %s is not a valid parameter for the model.' % str(key))


    def run(self, duration=None):
        """Runs the network for a particular duration.

        Ca be called several times for consecutive runs.

        :param duration:

            Duration of a run, if none is specified the duration is taken from
            the parameters. Thus, if a duration has been specified before, this is
            overridden if specified here.

        :return:

            The result dictionary


        """
        for param in self.parameters.values():
            if isinstance(param, np.ndarray):
                param.flags.writeable = True
        dt = float(self.parameters.get('dt'))
        sample_dt = float(self.parameters.get('sample_dt'))
        current_time = float(self.parameters.get('current_time', 0.0))
        exp_steps = self.parameters.get('exp_steps', 1000000)
        precomputed_exp = self.parameters.get('precomputed_exp', None)
        min_value_exp = self.parameters.get('min_value_exp', None)
        max_value_exp = self.parameters.get('max_value_exp', None)
        # noise_seed = self.parameters.get('noise_seed', None)

        if duration is None:
            duration = float(self.parameters.get('duration'))
        else:
            duration = float(duration)
        sample_offset = self.parameters.get('sample_offset', 0)
        delay_offset = self.parameters.get('delay_offset', 0)
        max_delay = self.parameters.get('max_delay', None)

        sample_E = self.parameters.get(('exc_neurons', 'sample'), None)
        sample_I = self.parameters.get(('inh_neurons', 'sample'), None)

        sample_spikes_E = self.parameters.get(('exc_neurons', 'sample_spikes'), None)
        sample_spikes_I = self.parameters.get(('inh_neurons', 'sample_spikes'), None)

        N_E = self.parameters.get(('exc_neurons','N'), None)
        N_I = self.parameters.get(('inh_neurons','N'), None)

        V_E = self.parameters.get(('exc_neurons','V'), None)
        V_I = self.parameters.get(('inh_neurons','V'), None)
        w_E = self.parameters.get(('exc_neurons','w'), None)
        w_I = self.parameters.get(('inh_neurons','w'), None)

        refractory_E = self.parameters.get(('exc_neurons','refractory'), None)
        refractory_I = self.parameters.get(('inh_neurons','refractory'), None)
        tau_refr_E = float(self.parameters.get(('exc_neurons','tau_refr')))
        tau_refr_I = float(self.parameters.get(('inh_neurons','tau_refr')))
        # D_E = self.parameters.get(('exc_neurons','D'), 0.0)
        # D_I = self.parameters.get(('inh_neurons','D'), 0.0)
        a_E = self.parameters.get(('exc_neurons','a'), 0.0)
        a_I = self.parameters.get(('inh_neurons','a'), 0.0)
        b_E = self.parameters.get(('exc_neurons','b'), 0.0)
        b_I = self.parameters.get(('inh_neurons','b'), 0.0)
        tau_w_E = float(self.parameters.get(('exc_neurons','tau_w'), 0.1))
        tau_w_I = float(self.parameters.get(('inh_neurons','tau_w'), 0.1))
        I_Aff_bias_E = self.parameters.get(('exc_neurons', 'I_Aff_bias'), 0.0)
        I_Aff_bias_I = self.parameters.get(('inh_neurons', 'I_Aff_bias'), 0.0)
        C_E = float(self.parameters.get(('exc_neurons','C')))
        C_I = float(self.parameters.get(('inh_neurons','C')))
        gL_E = float(self.parameters.get(('exc_neurons','gL')))
        gL_I = float(self.parameters.get(('inh_neurons','gL')))
        EL_E = float(self.parameters.get(('exc_neurons','EL')))
        EL_I = float(self.parameters.get(('inh_neurons','EL')))
        VT_E = float(self.parameters.get(('exc_neurons','VT'), 0.0))
        VT_I = float(self.parameters.get(('inh_neurons','VT'), 0.0))
        DeltaT_E = float(self.parameters.get(('exc_neurons','DeltaT'), 0.0))
        DeltaT_I = float(self.parameters.get(('inh_neurons','DeltaT'), 0.0))
        Vth_E = float(self.parameters.get(('exc_neurons','Vth')))
        Vth_I = float(self.parameters.get(('inh_neurons','Vth')))
        Vr_E = float(self.parameters.get(('exc_neurons','Vr')))
        Vr_I = float(self.parameters.get(('inh_neurons','Vr')))

        maxrate_E = self.parameters.get(('exc_neurons','maxrate'), None)
        maxrate_I = self.parameters.get(('inh_neurons','maxrate'), None)

        share_AMPA_EE = self.parameters.get(('exc2exc_synapses', 'share_AMPA'), 0.7)
        share_AMPA_IE = self.parameters.get(('exc2inh_synapses', 'share_AMPA'), 0.7)
        share_AMPA_EA = self.parameters.get(('aff2exc_synapses', 'share_AMPA'), 0.7)
        share_AMPA_IA = self.parameters.get(('aff2inh_synapses', 'share_AMPA'), 0.7)

        g_AMPA_EE = self.parameters.get(('exc2exc_synapses', 'g_AMPA'), None)
        g_NMDA_EE = self.parameters.get(('exc2exc_synapses', 'g_NMDA'), None)
        g_EI = self.parameters.get(('inh2exc_synapses', 'g'), None)
        g_AMPA_IE = self.parameters.get(('exc2inh_synapses', 'g_AMPA'), None)
        g_NMDA_IE = self.parameters.get(('exc2inh_synapses', 'g_NMDA'), None)
        g_II = self.parameters.get(('inh2inh_synapses', 'g'), None)
        g_AMPA_EA = self.parameters.get(('aff2exc_synapses', 'g_AMPA'), None)
        g_NMDA_EA = self.parameters.get(('aff2exc_synapses', 'g_NMDA'), None)
        g_AMPA_IA = self.parameters.get(('aff2inh_synapses', 'g_AMPA'), None)
        g_NMDA_IA = self.parameters.get(('aff2inh_synapses', 'g_NMDA'), None)

        h_NMDA_EE = self.parameters.get(('exc2exc_synapses', 'h_NMDA'), None)
        h_NMDA_IE = self.parameters.get(('exc2inh_synapses', 'h_NMDA'), None)
        h_NMDA_EA = self.parameters.get(('aff2exc_synapses', 'h_NMDA'), None)
        h_NMDA_IA = self.parameters.get(('aff2inh_synapses', 'h_NMDA'), None)

        I_EE = self.parameters.get(('exc2exc_synapses', 'I'), None)
        I_EI = self.parameters.get(('inh2exc_synapses', 'I'), None)
        I_IE = self.parameters.get(('exc2inh_synapses', 'I'), None)
        I_II = self.parameters.get(('inh2inh_synapses', 'I'), None)
        I_EA = self.parameters.get(('aff2exc_synapses', 'I'), None)
        I_IA = self.parameters.get(('aff2inh_synapses', 'I'), None)

        tau_rise_NMDA_EE = float(self.parameters.get(('exc2exc_synapses', 'tau_rise_NMDA'), 0.005))
        tau_rise_NMDA_IE = float(self.parameters.get(('exc2inh_synapses', 'tau_rise_NMDA'), 0.005))
        tau_rise_NMDA_EA = float(self.parameters.get(('aff2exc_synapses', 'tau_rise_NMDA'), 0.005))
        tau_rise_NMDA_IA = float(self.parameters.get(('aff2inh_synapses', 'tau_rise_NMDA'), 0.005))

        tau_decay_AMPA_EE = float(self.parameters.get(('exc2exc_synapses', 'tau_decay_AMPA'), 0.003))
        tau_decay_NMDA_EE = float(self.parameters.get(('exc2exc_synapses', 'tau_decay_NMDA'), 0.08))
        tau_decay_EI = float(self.parameters.get(('inh2exc_synapses', 'tau_decay'), 0.005))
        tau_decay_AMPA_IE = float(self.parameters.get(('exc2inh_synapses', 'tau_decay_AMPA'), 0.003))
        tau_decay_NMDA_IE = float(self.parameters.get(('exc2inh_synapses', 'tau_decay_NMDA'), 0.08))
        tau_decay_II = float(self.parameters.get(('inh2inh_synapses', 'tau_decay'), 0.005))
        tau_decay_AMPA_EA = float(self.parameters.get(('aff2exc_synapses', 'tau_decay_AMPA'), 0.003))
        tau_decay_NMDA_EA = float(self.parameters.get(('aff2exc_synapses', 'tau_decay_NMDA'), 0.08))
        tau_decay_AMPA_IA = float(self.parameters.get(('aff2inh_synapses', 'tau_decay_AMPA'), 0.003))
        tau_decay_NMDA_IA = float(self.parameters.get(('aff2inh_synapses', 'tau_decay_NMDA'), 0.08))

        E_syn_EE = float(self.parameters.get(('exc2exc_synapses', 'E_syn'), 0.0))
        E_syn_EI = float(self.parameters.get(('inh2exc_synapses', 'E_syn'), -0.08))
        E_syn_IE = float(self.parameters.get(('exc2inh_synapses', 'E_syn'), 0.0))
        E_syn_II = float(self.parameters.get(('inh2inh_synapses', 'E_syn'), -0.08))
        E_syn_EA = float(self.parameters.get(('aff2exc_synapses', 'E_syn'), 0.0))
        E_syn_IA = float(self.parameters.get(('aff2inh_synapses', 'E_syn'), 0.0))

        input_EE = self.parameters.get(('exc2exc_synapses', 'input'), None)
        input_EI = self.parameters.get(('inh2exc_synapses', 'input'), None)
        input_IE = self.parameters.get(('exc2inh_synapses', 'input'), None)
        input_II = self.parameters.get(('inh2inh_synapses', 'input'), None)

        input_EA = self.parameters.get(('aff2exc_synapses', 'input'), None)
        input_IA = self.parameters.get(('aff2inh_synapses', 'input'), None)

        S_EE = self.parameters.get(('exc2exc_synapses', 'S'), None)
        S_EI = self.parameters.get(('inh2exc_synapses', 'S'), None)
        S_IE = self.parameters.get(('exc2inh_synapses', 'S'), None)
        S_II = self.parameters.get(('inh2inh_synapses', 'S'), None)
        S_EA = self.parameters.get(('aff2exc_synapses', 'S'), None)
        S_IA = self.parameters.get(('aff2inh_synapses', 'S'), None)

        S_delay_EE = self.parameters.get(('exc2exc_synapses', 'S_delay'), None)
        S_delay_EI = self.parameters.get(('inh2exc_synapses', 'S_delay'), None)
        S_delay_IE = self.parameters.get(('exc2inh_synapses', 'S_delay'), None)
        S_delay_II = self.parameters.get(('inh2inh_synapses', 'S_delay'), None)
        S_delay_EA = self.parameters.get(('aff2exc_synapses', 'S_delay'), None)
        S_delay_IA = self.parameters.get(('aff2inh_synapses', 'S_delay'), None)

        mat_tuple_EE = self.parameters.get(('exc2exc_synapses', 'mat_tuple'), None)
        mat_tuple_EI = self.parameters.get(('inh2exc_synapses', 'mat_tuple'), None)
        mat_tuple_IE = self.parameters.get(('exc2inh_synapses', 'mat_tuple'), None)
        mat_tuple_II = self.parameters.get(('inh2inh_synapses', 'mat_tuple'), None)
        mat_tuple_EA = self.parameters.get(('aff2exc_synapses', 'mat_tuple'), None)
        mat_tuple_IA = self.parameters.get(('aff2inh_synapses', 'mat_tuple'), None)

        spikes_EA = self.parameters.get(('aff2exc_synapses', 'spikes'), None)
        spikes_IA = self.parameters.get(('aff2inh_synapses', 'spikes'), None)


        try:
            print "Starting Network Simulation, current time is %.3f s" % current_time

            # assert (sample_dt / dt).is_integer()

            if N_E is None:
                N_E = len(V_E)
            if N_I is None:
                N_I = len(V_I)

            if V_E is None:
                print 'No initial values for exc V, setting to EL'
                V_E = np.ones(N_E)*EL_E
            if V_I is None:
                print 'No initial values for inh V, setting to EL'
                V_I = np.ones(N_I)*EL_I

            if w_E is None:
                print 'No initial values for exc w, setting to 0'
                w_E = np.zeros(N_E)
            if w_I is None:
                print 'No initial values for inh w, setting to 0'
                w_I = np.zeros(N_I)

            if g_AMPA_EE is None:
                print 'No initial values for exc2exc g_AMPA found, setting to 0'
                g_AMPA_EE = np.zeros(N_E)
            if g_NMDA_EE is None:
                print 'No initial values for exc2exc g_NMDA found, setting to 0'
                g_NMDA_EE = np.zeros(N_E)
            if h_NMDA_EE is None:
                print 'No initial values for exc2exc h_NMDA found, setting to 0'
                h_NMDA_EE = np.zeros(N_E)
            if I_EE is None:
                print 'No initial values for exc2exc I found, setting to 0'
                I_EE = np.zeros(N_E)

            if g_EI is None:
                print 'No initial values for inh2exc g found, setting to 0'
                g_EI = np.zeros(N_E)
            if I_EI is None:
                print 'No initial values for inh2exc I found, setting to 0'
                I_EI = np.zeros(N_E)

            if g_AMPA_IE is None:
                print 'No initial values for exc2inh g_AMPA found, setting to 0'
                g_AMPA_IE = np.zeros(N_I)
            if g_NMDA_IE is None:
                print 'No initial values for exc2inh g_NMDA found, setting to 0'
                g_NMDA_IE = np.zeros(N_I)
            if h_NMDA_IE is None:
                print 'No initial values for exc2inh h_NMDA found, setting to 0'
                h_NMDA_IE = np.zeros(N_I)
            if I_IE is None:
                print 'No initial values for exc2inh I found, setting to 0'
                I_IE = np.zeros(N_I)

            if g_II is None:
                print 'No initial values for inh2inh g found, setting to 0'
                g_II = np.zeros(N_I)
            if I_II is None:
                print 'No initial values for inh2inh I found, setting to 0'
                I_II = np.zeros(N_I)

            if g_AMPA_EA is None:
                print 'No initial values for aff2exc g_AMPA found, setting to 0'
                g_AMPA_EA = np.zeros(N_E)
            if g_NMDA_EA is None:
                print 'No initial values for aff2exc g_NMDA found, setting to 0'
                g_NMDA_EA = np.zeros(N_E)
            if h_NMDA_EA is None:
                print 'No initial values for aff2exc h_NMDA found, setting to 0'
                h_NMDA_EA = np.zeros(N_E)
            if I_EA is None:
                print 'No initial values for aff2exc I found, setting to 0'
                I_EA = np.zeros(N_E)

            if g_AMPA_IA is None:
                print 'No initial values for aff2inh g_AMPA found, setting to 0'
                g_AMPA_IA = np.zeros(N_I)
            if g_NMDA_IA is None:
                print 'No initial values for aff2inh g_NMDA found, setting to 0'
                g_NMDA_IA = np.zeros(N_I)
            if h_NMDA_IA is None:
                print 'No initial values for aff2inh h_NMDA found, setting to 0'
                h_NMDA_IA = np.zeros(N_I)
            if I_IA is None:
                print 'No initial values for aff2inh I found, setting to 0'
                I_IA = np.zeros(N_I)

            if sample_E is None:
                sample_E = np.array(range(N_E))
            else:
                print 'Sampling from %d exc neurons' % len(sample_E)

            nsE = len(sample_E)

            if sample_spikes_E is None:
                sample_spikes_E = np.array(range(N_E))
            else:
                print 'Sampling spikes from %d exc neurons' % len(sample_spikes_E)

            nsSE = len(sample_spikes_E)

            if sample_I is None:
                sample_I = np.array(range(N_I))
            else:
                print 'Sampling from %d inh neurons' % len(sample_I)

            nsI = len(sample_I)

            if sample_spikes_I is None:
                sample_spikes_I = np.array(range(N_I))
            else:
                print 'Sampling spikes from %d inh neurons' % len(sample_spikes_I)

            nsSI = len(sample_spikes_I)

            if max_delay is None:
                print 'Checking Max Delay'

                max_delay = 0.0

                S_EE, S_delay_EE, delay_in_mat = check_matrix_and_delay(S_EE, S_delay_EE, N_E, N_E,
                                                                        name = 'S_EE')
                max_delay = max(max_delay, delay_in_mat)

                S_EI, S_delay_EI, delay_in_mat = check_matrix_and_delay(S_EI, S_delay_EI, N_I, N_E,
                                                                        name = 'S_EI')
                max_delay = max(max_delay, delay_in_mat)

                S_IE, S_delay_IE, delay_in_mat = check_matrix_and_delay(S_IE, S_delay_IE, N_E, N_I,
                                                                        name = 'S_IE')
                max_delay = max(max_delay, delay_in_mat)

                S_II, S_delay_II, delay_in_mat = check_matrix_and_delay(S_II, S_delay_II, N_I, N_I,
                                                                        name = 'S_II')
                max_delay = max(max_delay, delay_in_mat)

                if S_IA is None:
                    nAI = 1
                else:
                    nAI = S_IA.shape[0]
                if S_EA is None:
                    nAE = 1
                else:
                    nAE = S_EA.shape[0]

                S_EA, S_EA_delay, delay_in_mat = check_matrix_and_delay(S_EA, S_delay_EA, nAE, N_E,
                                                                        name = 'S_EA')
                max_delay = max(max_delay, delay_in_mat)

                S_IA, S_IA_delay, delay_in_mat = check_matrix_and_delay(S_IA, S_delay_IA, nAI, N_I,
                                                                        name = 'S_IA')
                max_delay = max(max_delay, delay_in_mat)


                print 'Delay Checking complete'
            else:
                max_delay = float(max_delay)


            if max_delay < tau_refr_E:
                max_delay = tau_refr_E
            if max_delay < tau_refr_I:
                max_delay = tau_refr_I

            print 'Using max delay of %.3f s' % max_delay
            duration=float(duration)
            steps = np.rint(duration/dt).astype(int)
            #print (max_delay, dt)
            max_delay_ints = np.ceil(max_delay/dt).astype(int)+1
            refr_E_int = np.rint(tau_refr_E/dt).astype(int)
            refr_I_int = np.rint(tau_refr_I/dt).astype(int)
            sample_idx = np.rint(sample_dt/dt).astype(int)
            sample_steps = int((steps-sample_offset))/sample_idx
            if int((steps-sample_offset)) % sample_idx != 0:
                sample_steps += 1

            print 'Sampling every %.6f s, i.e. every %d steps' % (sample_dt, sample_idx)

            if mat_tuple_EE is None:
                print 'Converting matrix S_EE'
                mat_tuple_EE = convert_matrix_jit(S_EE, S_delay_EE, dt)

            if mat_tuple_EI is None:
                print 'Converting matrix S_EI'
                mat_tuple_EI = convert_matrix_jit(S_EI, S_delay_EI, dt)

            if mat_tuple_IE is None:
                print 'Converting matrix S_IE'
                mat_tuple_IE = convert_matrix_jit(S_IE, S_delay_IE, dt)

            if mat_tuple_II is None:
                print 'Converting matrix S_II'
                mat_tuple_II = convert_matrix_jit(S_II, S_delay_II, dt)

            if mat_tuple_EA is None:
                print 'Converting matrix S_EA'
                mat_tuple_EA = convert_matrix_jit(S_EA, S_EA_delay, dt)

            if mat_tuple_IA is None:
                print 'Converting matrix S_IA'
                mat_tuple_IA = convert_matrix_jit(S_IA, S_IA_delay, dt)

            if spikes_EA is None:
                print('No afferent spikes to exc found')
                spikes_EA = np.array([])
            if spikes_IA is None:
                print('No afferent spikes to inh found')
                spikes_IA = np.array([])

            no_exc_exponential = False
            if VT_E == 0.0 and DeltaT_E == 0.0:
                print 'Did not find exc exponential term'
                no_exc_exponential = True

            no_inh_exponential = False
            if VT_I == 0.0 and DeltaT_I == 0.0:
                print 'Did not find inh exponential term'
                no_inh_exponential = True

            no_exponential = no_exc_exponential and no_inh_exponential

            times = np.zeros(steps)
            sample_times = np.zeros(sample_steps)
            times[-1] = current_time

            if np.isscalar(I_Aff_bias_E):
                print 'Found float in exc input current convert %.2f to matrix' % I_Aff_bias_E
                I_Aff_bias_E = np.ones((N_E,1), order='F')*I_Aff_bias_E
            elif I_Aff_bias_E.ndim==1:
                print 'Found vector in exc input current convert %.2f (mean) to matrix' % np.mean(I_Aff_bias_E)
                new_I_Aff_E = np.zeros((N_E,1), order='F')
                new_I_Aff_E[:,0] = I_Aff_bias_E
                I_Aff_bias_E = new_I_Aff_E

            if np.isscalar(I_Aff_bias_I):
                print 'Found float in inh input current convert %.2f to matrix' % I_Aff_bias_I
                I_Aff_bias_I = np.ones((N_I,1), order='F')*I_Aff_bias_I
            elif I_Aff_bias_I.ndim==1:
                print 'Found vector in inh input current convert %.2f (mean) to matrix' % np.mean(I_Aff_bias_I)
                new_I_Aff_I = np.zeros((N_I,1), order='F')
                new_I_Aff_I[:,0] = I_Aff_bias_I
                I_Aff_bias_I = new_I_Aff_I

            if b_E != 0:
                print 'Found exc spike frequency adaptation of %f' % b_E
            if b_I != 0:
                print 'Found inh spike frequency adaptation of %f' % b_I
            if a_E != 0:
                print 'Found exc sub-threshold adaptation of %f' % a_E
            if a_I != 0:
                print 'Found inh sub-threshold adaptation of %f' % a_I

            mV_E = np.zeros((nsE, sample_steps), order='F')
            mV_I = np.zeros((nsI, sample_steps), order='F')
            mw_E = np.zeros((nsE, sample_steps), order='F')
            mw_I = np.zeros((nsI, sample_steps), order='F')
            mg_AMPA_EE = np.zeros((nsE, sample_steps), order='F')
            mg_NMDA_EE = np.zeros((nsE, sample_steps), order='F')
            mg_EI = np.zeros((nsE, sample_steps), order='F')
            mg_AMPA_IE = np.zeros((nsI, sample_steps), order='F')
            mg_NMDA_IE = np.zeros((nsI, sample_steps), order='F')
            mg_II = np.zeros((nsI, sample_steps), order='F')
            mg_AMPA_EA = np.zeros((nsE, sample_steps), order='F')
            mg_NMDA_EA = np.zeros((nsE, sample_steps), order='F')
            mg_AMPA_IA = np.zeros((nsI, sample_steps), order='F')
            mg_NMDA_IA = np.zeros((nsI, sample_steps), order='F')
            mI_EE = np.zeros((nsE, sample_steps), order='F')
            mI_EI = np.zeros((nsE, sample_steps), order='F')
            mI_IE = np.zeros((nsI, sample_steps), order='F')
            mI_II = np.zeros((nsI, sample_steps), order='F')
            mI_EA = np.zeros((nsE, sample_steps), order='F')
            mI_IA = np.zeros((nsI, sample_steps), order='F')

            if maxrate_E is None:
                if tau_refr_E > 0.0:
                    maxrate_E = 1.0/tau_refr_E
                else:
                    maxrate_E = 1.0/dt
                print 'Assuming exc maximum rate %.2f' % maxrate_E
            else:
                maxrate_E = float(maxrate_E)

            if maxrate_I is None:
                if tau_refr_I > 0.0:
                    maxrate_I = 1.0/tau_refr_I
                else:
                    maxrate_I = 1.0/dt
                print 'Assuming inh maximum rate %.2f' % maxrate_I
            else:
                maxrate_I = float(maxrate_I)

            max_spikes_E = int(maxrate_E*duration*nsSE)+1
            max_spikes_I = int(maxrate_I*duration*nsSI)+1


            spikes_E = np.ones((max_spikes_E, 2))*-1.0
            spikes_I = np.ones((max_spikes_I, 2))*-1.0
            binspikes_E = np.zeros(N_E)
            binspikes_I = np.zeros(N_I)

            if refractory_E is None:
                print 'Creating new exc refratory'
                refractory_E = np.zeros(N_E, dtype=int)
            if refractory_I is None:
                print 'Creating new inh refratory'
                refractory_I = np.zeros(N_E, dtype=int)

            print 'Creating spike inputs'
            input_EE = create_inputs(N_E, input_EE, max_delay_ints,'exc2exc')
            input_EI = create_inputs(N_E, input_EI, max_delay_ints, 'inh2exc')
            input_IE = create_inputs(N_I, input_IE, max_delay_ints, 'exc2inh')
            input_II = create_inputs(N_I, input_II, max_delay_ints, 'inh2inh')

            input_EA = create_inputs(N_E, input_EA, max_delay_ints, 'aff2exc')
            input_IA = create_inputs(N_I, input_IA, max_delay_ints, 'aff2inh')

            print 'Filtering afferent spikes'
            spikes_AE_reduced = reduce_afferent_spiketimes(spikes_EA, current_time, duration)
            spikes_AI_reduced = reduce_afferent_spiketimes(spikes_IA, current_time, duration)

            if no_exponential:
                print 'Ignoring exponential term in both neurons'
                precomputed_exp=np.zeros(1)

            elif precomputed_exp is None:
                print 'Pre Computing exponential function with %d steps' % exp_steps

                if max_value_exp is None:
                    maxV_E = max(Vth_E, VT_E)
                    maxV_E = (maxV_E-VT_E)/DeltaT_E
                    maxV_I = max(Vth_I, VT_I)
                    maxV_I = (maxV_I-VT_I)/DeltaT_I
                    max_value_exp = max(maxV_I, maxV_E)
                else:
                    max_value_exp = float(max_value_exp)

                if min_value_exp is None:
                    minV_E = min(E_syn_EI, EL_E)
                    minV_E = (minV_E - VT_E)/DeltaT_E
                    minV_I = min(E_syn_II, EL_I)
                    minV_I = (minV_I - VT_I)/DeltaT_I
                    min_value_exp = min(minV_I, minV_E)
                else:
                    min_value_exp = float(min_value_exp)

                the_range = max_value_exp-min_value_exp
                min_value_exp = min_value_exp-0.25*the_range
                exp_delta = (max_value_exp-min_value_exp)/(exp_steps-1)
                x_values = np.array(range(exp_steps)) * exp_delta + min_value_exp
                precomputed_exp = np.exp(x_values)
            else:
                exp_delta = (max_value_exp-min_value_exp)/(exp_steps-1)

            spike_counts_E = np.zeros(N_E)
            spike_counts_I = np.zeros(N_I)


            mean_w_E = np.zeros(N_E)
            mean_V_E = np.zeros(N_E)
            mean_I_EE = np.zeros(N_E)
            mean_I_EI = np.zeros(N_E)
            mean_I_EA = np.zeros(N_E)
            mean_g_AMPA_EE = np.zeros(N_E)
            mean_g_NMDA_EE = np.zeros(N_E)
            mean_g_EI = np.zeros(N_E)
            mean_g_AMPA_EA = np.zeros(N_E)
            mean_g_NMDA_EA = np.zeros(N_E)

            mean_w_I = np.zeros(N_I)
            mean_V_I = np.zeros(N_I)
            mean_I_IE = np.zeros(N_I)
            mean_I_II = np.zeros(N_I)
            mean_I_IA = np.zeros(N_I)
            mean_g_AMPA_IE = np.zeros(N_I)
            mean_g_NMDA_IE = np.zeros(N_I)
            mean_g_II = np.zeros(N_I)
            mean_g_AMPA_IA = np.zeros(N_I)
            mean_g_NMDA_IA = np.zeros(N_I)

            print 'Inputs complete. Starting integration...'
            _adlif_poisson_njit(N_E=N_E, N_I=N_I,
                                V_E=V_E, V_I=V_I,
                              w_E=w_E, w_I=w_I,
                              C_E=C_E, C_I=C_I,
                              gL_E=gL_E, gL_I=gL_I,
                              EL_E=EL_E, EL_I=EL_I,
                              DeltaT_E=DeltaT_E, DeltaT_I=DeltaT_I,
                              VT_E=VT_E, VT_I=VT_I,
                              Vth_E=Vth_E, Vth_I=Vth_I,
                              Vr_E=Vr_E, Vr_I=Vr_I,
                              tau_w_E=tau_w_E, tau_w_I=tau_w_I,
                              a_E=a_E, a_I=a_I,
                              b_E=b_E, b_I=b_I,
                              refr_E_int=refr_E_int, refr_I_int=refr_I_int,
                              refractory_E=refractory_E, refractory_I=refractory_I,
                              input_EE=input_EE, input_EI=input_EI,
                              input_IE=input_IE, input_II=input_II,
                              input_EA=input_EA, input_IA=input_IA,
                              g_AMPA_EE=g_AMPA_EE, g_NMDA_EE=g_NMDA_EE,
                              g_EI=g_EI,g_II=g_II,
                              g_AMPA_IE=g_AMPA_IE, g_NMDA_IE=g_NMDA_IE,
                              g_AMPA_EA=g_AMPA_EA, g_NMDA_EA=g_NMDA_EA,
                              g_AMPA_IA=g_AMPA_IA, g_NMDA_IA=g_NMDA_IA,
                              h_NMDA_EE=h_NMDA_EE, h_NMDA_IE=h_NMDA_IE,
                              h_NMDA_EA=h_NMDA_EA, h_NMDA_IA=h_NMDA_IA,
                              I_EE=I_EE, I_EI=I_EI,
                              I_IE=I_IE, I_II=I_II,
                              I_EA=I_EA, I_IA=I_IA,
                              E_syn_EE=E_syn_EE, E_syn_EI=E_syn_EI,
                              E_syn_II=E_syn_II, E_syn_IE=E_syn_IE,
                              E_syn_EA=E_syn_EA, E_syn_IA=E_syn_IA,
                              share_AMPA_EE=share_AMPA_EE, share_AMPA_IE=share_AMPA_IE,
                              share_AMPA_EA=share_AMPA_EA, share_AMPA_IA=share_AMPA_IA,
                              tau_rise_NMDA_EE=tau_rise_NMDA_EE, tau_rise_NMDA_IE=tau_rise_NMDA_IE,
                              tau_rise_NMDA_EA=tau_rise_NMDA_EA, tau_rise_NMDA_IA=tau_rise_NMDA_IA,
                              tau_decay_AMPA_EE=tau_decay_AMPA_EE, tau_decay_NMDA_EE=tau_decay_NMDA_EE,
                              tau_decay_EI=tau_decay_EI,  tau_decay_II=tau_decay_II,
                              tau_decay_AMPA_IE=tau_decay_AMPA_IE, tau_decay_NMDA_IE=tau_decay_NMDA_IE,
                              tau_decay_AMPA_EA=tau_decay_AMPA_EA, tau_decay_NMDA_EA=tau_decay_NMDA_EA,
                              tau_decay_AMPA_IA=tau_decay_AMPA_IA, tau_decay_NMDA_IA=tau_decay_NMDA_IA,
                              # noise_E=noise_E, noise_I=noise_I,
                              S_EE_nonzero=mat_tuple_EE[0], S_EE_values=mat_tuple_EE[1], S_EE_delay=mat_tuple_EE[2], S_EE_nzlength=mat_tuple_EE[3],
                              S_EI_nonzero=mat_tuple_EI[0], S_EI_values=mat_tuple_EI[1], S_EI_delay=mat_tuple_EI[2], S_EI_nzlength=mat_tuple_EI[3],
                              S_IE_nonzero=mat_tuple_IE[0], S_IE_values=mat_tuple_IE[1], S_IE_delay=mat_tuple_IE[2], S_IE_nzlength=mat_tuple_IE[3],
                              S_II_nonzero=mat_tuple_II[0], S_II_values=mat_tuple_II[1], S_II_delay=mat_tuple_II[2], S_II_nzlength=mat_tuple_II[3],
                              S_EA_nonzero=mat_tuple_EA[0], S_EA_values=mat_tuple_EA[1], S_EA_delay=mat_tuple_EA[2], S_EA_nzlength=mat_tuple_EA[3],
                              S_IA_nonzero=mat_tuple_IA[0], S_IA_values=mat_tuple_IA[1], S_IA_delay=mat_tuple_IA[2], S_IA_nzlength=mat_tuple_IA[3],
                              I_Aff_E=I_Aff_bias_E, I_Aff_I=I_Aff_bias_I,
                              spikes_E=spikes_E, spikes_I=spikes_I,
                              spike_counts_E=spike_counts_E, spike_counts_I=spike_counts_I,
                              binspikes_E=binspikes_E, binspikes_I=binspikes_I,
                              spikes_AE=spikes_AE_reduced, spikes_AI=spikes_AI_reduced,
                              mV_E=mV_E, mV_I=mV_I,
                              mw_E=mw_E, mw_I=mw_I,
                              mg_AMPA_EE=mg_AMPA_EE, mg_NMDA_EE=mg_NMDA_EE,
                              mg_EI=mg_EI, mg_II=mg_II,
                              mg_AMPA_IE=mg_AMPA_IE, mg_NMDA_IE=mg_NMDA_IE,
                              mg_AMPA_EA=mg_AMPA_EA, mg_NMDA_EA=mg_NMDA_EA,
                              mg_AMPA_IA=mg_AMPA_IA, mg_NMDA_IA=mg_NMDA_IA,
                              mI_EE=mI_EE, mI_EI=mI_EI,
                              mI_IE=mI_IE, mI_II=mI_II,
                              mI_EA=mI_EA, mI_IA=mI_IA,
                              nsE=nsE, nsI=nsI,
                              nsSE=nsSE, nsSI=nsSI,
                              sample_E=sample_E, sample_I=sample_I,
                              sample_spikes_E=sample_spikes_E, sample_spikes_I=sample_spikes_I,
                              mean_V_E=mean_V_E, mean_V_I=mean_V_I,
                              mean_w_E=mean_w_E, mean_w_I=mean_w_I,
                              mean_g_AMPA_EE=mean_g_AMPA_EE, mean_g_NMDA_EE=mean_g_NMDA_EE,
                              mean_g_EI=mean_g_EI, mean_g_II=mean_g_II,
                              mean_g_AMPA_IE=mean_g_AMPA_IE, mean_g_NMDA_IE=mean_g_NMDA_IE,
                              mean_g_AMPA_EA=mean_g_AMPA_EA, mean_g_NMDA_EA=mean_g_NMDA_EA,
                              mean_g_AMPA_IA=mean_g_AMPA_IA, mean_g_NMDA_IA=mean_g_NMDA_IA,
                              mean_I_EE=mean_I_EE, mean_I_EI=mean_I_EI,
                              mean_I_IE=mean_I_IE, mean_I_II=mean_I_II,
                              mean_I_EA=mean_I_EA, mean_I_IA=mean_I_IA,
                              times=times, dt=dt,
                              steps=steps, max_delay_ints=max_delay_ints,
                              sample_idx=sample_idx, sample_offset=sample_offset,
                              sample_times=sample_times, precomputed_exp=precomputed_exp,
                              min_value_exp=min_value_exp, max_value_exp=max_value_exp,
                              exp_delta=exp_delta)

            print '... Integration complete. Passing over data to next run.'
            current_time = times[-1]

            new_delay_offset = steps % max_delay_ints
            new_sample_offset = (steps+sample_offset) % sample_idx

            input_EE = roll_inputs(input_EE, new_delay_offset, max_delay_ints)
            input_EI = roll_inputs(input_EI, new_delay_offset, max_delay_ints)
            input_IE = roll_inputs(input_IE, new_delay_offset, max_delay_ints)
            input_II = roll_inputs(input_II, new_delay_offset, max_delay_ints)

            input_EA = roll_inputs(input_EA, new_delay_offset, max_delay_ints)
            input_IA = roll_inputs(input_IA, new_delay_offset, max_delay_ints)

            self.parameters['dt'] = dt
            self.parameters['sample_dt'] = sample_dt
            self.parameters['current_time'] = current_time
            self.parameters['exp_steps'] = exp_steps
            self.parameters['precomputed_exp'] = precomputed_exp
            self.parameters['min_value_exp'] = min_value_exp
            self.parameters['max_value_exp'] = max_value_exp

            self.parameters['duration'] = duration
            self.parameters['sample_offset'] = new_sample_offset
            self.parameters['delay_offset'] = new_delay_offset
            self.parameters['max_delay'] = max_delay

            self.parameters[('exc_neurons', 'sample')] = sample_E
            self.parameters[('inh_neurons', 'sample')] = sample_I

            self.parameters[('exc_neurons', 'sample_spikes')] = sample_spikes_E
            self.parameters[('inh_neurons', 'sample_spikes')] = sample_spikes_I

            self.parameters[('exc_neurons','N')] = N_E
            self.parameters[('inh_neurons','N')] = N_I

            self.parameters[('exc_neurons','V')] = V_E
            self.parameters[('inh_neurons','V')] = V_I
            self.parameters[('exc_neurons','w')] = w_E
            self.parameters[('inh_neurons','w')] = w_I

            self.parameters[('exc_neurons','refractory')] = refractory_E
            self.parameters[('inh_neurons','refractory')] = refractory_I
            self.parameters[('exc_neurons','tau_refr')] = tau_refr_E
            self.parameters[('inh_neurons','tau_refr')] = tau_refr_I
            # self.parameters[('exc_neurons','D')] = D_E
            # self.parameters[('inh_neurons','D')] = D_I
            self.parameters[('exc_neurons','a')] = a_E
            self.parameters[('inh_neurons','a')] = a_I
            self.parameters[('exc_neurons','b')] = b_E
            self.parameters[('inh_neurons','b')] = b_I
            self.parameters[('exc_neurons', 'I_Aff_bias')] = I_Aff_bias_E
            self.parameters[('inh_neurons', 'I_Aff_bias')] = I_Aff_bias_I
            self.parameters[('exc_neurons','C')] = C_E
            self.parameters[('inh_neurons','C')] = C_I
            self.parameters[('exc_neurons','gL')] = gL_E
            self.parameters[('inh_neurons','gL')] = gL_I
            self.parameters[('exc_neurons','EL')] = EL_E
            self.parameters[('inh_neurons','EL')] = EL_I
            self.parameters[('exc_neurons','VT')] = VT_E
            self.parameters[('inh_neurons','VT')] = VT_I
            self.parameters[('exc_neurons','DeltaT')] = DeltaT_E
            self.parameters[('inh_neurons','DeltaT')] = DeltaT_I
            self.parameters[('exc_neurons','Vth')] = Vth_E
            self.parameters[('inh_neurons','Vth')] = Vth_I
            self.parameters[('exc_neurons','Vr')] = Vr_E
            self.parameters[('inh_neurons','Vr')] = Vr_I
            self.parameters[('exc_neurons','tau_w')] = tau_w_E
            self.parameters[('inh_neurons','tau_w')] = tau_w_I

            self.parameters[('exc_neurons','maxrate')] = maxrate_E
            self.parameters[('inh_neurons','maxrate')] = maxrate_I

            self.parameters[('exc2exc_synapses', 'g_AMPA')] = g_AMPA_EE
            self.parameters[('exc2exc_synapses', 'g_NMDA')] = g_NMDA_EE
            self.parameters[('inh2exc_synapses', 'g')] = g_EI
            self.parameters[('exc2inh_synapses', 'g_AMPA')] = g_AMPA_IE
            self.parameters[('exc2inh_synapses', 'g_NMDA')] = g_NMDA_IE
            self.parameters[('inh2inh_synapses', 'g')] = g_II
            self.parameters[('aff2exc_synapses', 'g_AMPA')] = g_AMPA_EA
            self.parameters[('aff2exc_synapses', 'g_NMDA')] = g_NMDA_EA
            self.parameters[('aff2inh_synapses', 'g_AMPA')] = g_AMPA_IA
            self.parameters[('aff2inh_synapses', 'g_NMDA')] = g_NMDA_IA

            self.parameters[('exc2exc_synapses', 'h_NMDA')] = h_NMDA_EE
            self.parameters[('exc2inh_synapses', 'h_NMDA')] = h_NMDA_IE
            self.parameters[('aff2exc_synapses', 'h_NMDA')] = h_NMDA_EA
            self.parameters[('aff2inh_synapses', 'h_NMDA')] = h_NMDA_IA

            self.parameters[('exc2exc_synapses', 'I')] = I_EE
            self.parameters[('inh2exc_synapses', 'I')] = I_EI
            self.parameters[('exc2inh_synapses', 'I')] = I_IE
            self.parameters[('inh2inh_synapses', 'I')] = I_II
            self.parameters[('aff2exc_synapses', 'I')] = I_EA
            self.parameters[('aff2inh_synapses', 'I')] = I_IA

            self.parameters[('exc2exc_synapses', 'tau_rise_NMDA')] = tau_rise_NMDA_EE
            self.parameters[('exc2inh_synapses', 'tau_rise_NMDA')] = tau_rise_NMDA_IE
            self.parameters[('aff2exc_synapses', 'tau_rise_NMDA')] = tau_rise_NMDA_EA
            self.parameters[('aff2inh_synapses', 'tau_rise_NMDA')] = tau_rise_NMDA_IA

            self.parameters[('exc2exc_synapses', 'tau_decay_AMPA')] = tau_decay_AMPA_EE
            self.parameters[('exc2exc_synapses', 'tau_decay_NMDA')] = tau_decay_NMDA_EE
            self.parameters[('inh2exc_synapses', 'tau_decay')] = tau_decay_EI
            self.parameters[('exc2inh_synapses', 'tau_decay_AMPA')] = tau_decay_AMPA_IE
            self.parameters[('exc2inh_synapses', 'tau_decay_NMDA')] = tau_decay_NMDA_IE
            self.parameters[('inh2inh_synapses', 'tau_decay')] = tau_decay_II
            self.parameters[('aff2exc_synapses', 'tau_decay_AMPA')] = tau_decay_AMPA_EA
            self.parameters[('aff2exc_synapses', 'tau_decay_NMDA')] = tau_decay_NMDA_EA
            self.parameters[('aff2inh_synapses', 'tau_decay_AMPA')] = tau_decay_AMPA_IA
            self.parameters[('aff2inh_synapses', 'tau_decay_NMDA')] = tau_decay_NMDA_IA



            self.parameters[('exc2exc_synapses', 'E_syn')] = E_syn_EE
            self.parameters[('inh2exc_synapses', 'E_syn')] = E_syn_EI
            self.parameters[('exc2inh_synapses', 'E_syn')] = E_syn_IE
            self.parameters[('inh2inh_synapses', 'E_syn')] = E_syn_II
            self.parameters[('aff2exc_synapses', 'E_syn')] = E_syn_EA
            self.parameters[('aff2inh_synapses', 'E_syn')] = E_syn_IA

            self.parameters[('exc2exc_synapses', 'input')] = input_EE
            self.parameters[('inh2exc_synapses', 'input')] = input_EI
            self.parameters[('exc2inh_synapses', 'input')] = input_IE
            self.parameters[('inh2inh_synapses', 'input')] = input_II

            self.parameters[('aff2exc_synapses', 'input')] = input_EA
            self.parameters[('aff2inh_synapses', 'input')] = input_IA

            self.parameters[('exc2exc_synapses', 'S')] = S_EE
            self.parameters[('inh2exc_synapses', 'S')] = S_EI
            self.parameters[('exc2inh_synapses', 'S')] = S_IE
            self.parameters[('inh2inh_synapses', 'S')] = S_II
            self.parameters[('aff2exc_synapses', 'S')] = S_EA
            self.parameters[('aff2inh_synapses', 'S')] = S_IA

            self.parameters[('exc2exc_synapses', 'S_delay')] = S_delay_EE
            self.parameters[('inh2exc_synapses', 'S_delay')] = S_delay_EI
            self.parameters[('exc2inh_synapses', 'S_delay')] = S_delay_IE
            self.parameters[('inh2inh_synapses', 'S_delay')] = S_delay_II
            self.parameters[('aff2exc_synapses', 'S_delay')] = S_delay_EA
            self.parameters[('aff2inh_synapses', 'S_delay')] = S_delay_IA

            self.parameters[('exc2exc_synapses', 'mat_tuple')] = mat_tuple_EE
            self.parameters[('inh2exc_synapses', 'mat_tuple')] = mat_tuple_EI
            self.parameters[('exc2inh_synapses', 'mat_tuple')] = mat_tuple_IE
            self.parameters[('inh2inh_synapses', 'mat_tuple')] = mat_tuple_II
            self.parameters[('aff2exc_synapses', 'mat_tuple')] = mat_tuple_EA
            self.parameters[('aff2inh_synapses', 'mat_tuple')] = mat_tuple_IA

            self.parameters[('aff2exc_synapses', 'spikes')] = spikes_EA
            self.parameters[('aff2inh_synapses', 'spikes')] = spikes_IA

            self.short_parameters = self._produce_short_dict(self.parameters)

            get_spikes=spikes_E[:,0]!=-1.0
            spikes_E = spikes_E[get_spikes,:]
            get_spikes=spikes_I[:,0]!=-1.0
            spikes_I = spikes_I[get_spikes,:]



            print 'Grapping Results'
            self.results= {
            ('exc_neurons', 'V') : mV_E,
            ('inh_neurons', 'V') : mV_I,
            ('exc_neurons', 'w') : mw_E,
            ('inh_neurons', 'w') : mw_I,
            ('exc_neurons', 'spikes') : spikes_E,
            ('inh_neurons', 'spikes') : spikes_I,
            ('exc2exc_synapses', 'g_AMPA'): mg_AMPA_EE,
            ('exc2exc_synapses', 'g_NMDA'): mg_NMDA_EE,
            ('exc2exc_synapses', 'g'): mg_AMPA_EE + mg_NMDA_EE,
            ('inh2exc_synapses', 'g'): mg_EI,
            ('exc2inh_synapses', 'g_AMPA'): mg_AMPA_IE,
            ('exc2inh_synapses', 'g_NMDA'): mg_NMDA_IE,
            ('exc2inh_synapses', 'g'): mg_AMPA_IE + mg_NMDA_IE,
            ('inh2inh_synapses', 'g'): mg_II,
            ('aff2exc_synapses', 'g_AMPA'): mg_AMPA_EA,
            ('aff2exc_synapses', 'g_NMDA'): mg_NMDA_EA,
            ('aff2exc_synapses', 'g'): mg_AMPA_EA + mg_NMDA_EA,
            ('aff2inh_synapses', 'g_AMPA'): mg_AMPA_IA,
            ('aff2inh_synapses', 'g_NMDA'): mg_NMDA_IA,
            ('aff2inh_synapses', 'g'): mg_AMPA_IA + mg_NMDA_IA,
            ('exc2exc_synapses', 'I'):mI_EE,
            ('inh2exc_synapses', 'I'):mI_EI,
            ('exc2inh_synapses', 'I'):mI_IE,
            ('inh2inh_synapses', 'I'):mI_II,
            ('aff2exc_synapses', 'I'):mI_EA,
            ('aff2inh_synapses', 'I'):mI_IA,
            ('exc2exc_synapses', 'g_mean_AMPA'):mean_g_AMPA_EE,
            ('exc2exc_synapses', 'g_mean_NMDA'):mean_g_NMDA_EE,
            ('exc2exc_synapses', 'g_mean'):mean_g_AMPA_EE + mean_g_NMDA_EE,
            ('inh2exc_synapses', 'g_mean'):mean_g_EI,
            ('exc2inh_synapses', 'g_mean_AMPA'):mean_g_AMPA_IE,
            ('exc2inh_synapses', 'g_mean_NMDA'):mean_g_NMDA_IE,
            ('exc2inh_synapses', 'g_mean'):mean_g_AMPA_IE + mean_g_NMDA_IE,
            ('inh2inh_synapses', 'g_mean'):mean_g_II,
            ('aff2exc_synapses', 'g_mean_AMPA'):mean_g_AMPA_EA,
            ('aff2exc_synapses', 'g_mean_NMDA'):mean_g_NMDA_EA,
            ('aff2exc_synapses', 'g_mean'):mean_g_AMPA_EA + mean_g_NMDA_EA,
            ('aff2inh_synapses', 'g_mean_AMPA'):mean_g_AMPA_IA,
            ('aff2inh_synapses', 'g_mean_NMDA'):mean_g_NMDA_IA,
            ('aff2inh_synapses', 'g_mean'):mean_g_AMPA_IA + mean_g_NMDA_IA,
            ('exc2exc_synapses', 'I_mean'):mean_I_EE,
            ('inh2exc_synapses', 'I_mean'):mean_I_EI,
            ('exc2inh_synapses', 'I_mean'):mean_I_IE,
            ('inh2inh_synapses', 'I_mean'):mean_I_II,
            ('aff2exc_synapses', 'I_mean'):mean_I_EA,
            ('aff2inh_synapses', 'I_mean'):mean_I_IA,
            ('exc_neurons', 'V_mean') : mean_V_E,
            ('inh_neurons', 'V_mean') : mean_V_I,
            ('exc_neurons', 'w_mean') : mean_w_E,
            ('inh_neurons', 'w_mean') : mean_w_I,
            ('exc_neurons', 'spikecounts') : spike_counts_E,
            ('inh_neurons', 'spikecounts') : spike_counts_I,
            'sample_times' : sample_times,
            'current_time' : current_time,
            'times' : times
            }

            self.short_results =  self._produce_short_dict(self.results)

            print 'Finished (sub) run of simulation'

            return self.results
        except Exception as e:
            print 'ERROR: %s' % str(e)
            raise

    @staticmethod
    def _produce_short_dict(dictionary):
        short_dictionary={}
        for key, val in dictionary.items():
            if isinstance(key, tuple):
                where = key[0]
                what = key[1]
                if where == 'exc_neurons':
                    short_dictionary[what+'_E'] = val
                elif where == 'inh_neurons':
                    short_dictionary[what+'_I'] = val
                elif where == 'exc2exc_synapses':
                    short_dictionary[what+'_EE'] = val
                elif where == 'inh2exc_synapses':
                    short_dictionary[what+'_EI'] = val
                elif where == 'exc2inh_synapses':
                    short_dictionary[what+'_IE'] = val
                elif where == 'inh2inh_synapses':
                    short_dictionary[what+'_II'] = val
                elif where == 'aff2exc_synapses':
                    short_dictionary[what+'_EA'] = val
                elif where == 'aff2inh_synapses':
                    short_dictionary[what+'_IA'] = val
                else:
                    raise RuntimeError('You shall not pass')
            else:
                short_dictionary[key] = val
        return short_dictionary


@njit
def _adlif_poisson_njit(N_E, N_I,
                          V_E, V_I,
                          w_E, w_I,
                          C_E, C_I,
                          gL_E, gL_I,
                          EL_E, EL_I,
                          DeltaT_E, DeltaT_I,
                          VT_E, VT_I,
                          Vth_E, Vth_I,
                          Vr_E, Vr_I,
                          tau_w_E, tau_w_I,
                          a_E, a_I,
                          b_E, b_I,
                          refr_E_int, refr_I_int,
                          refractory_E, refractory_I,
                          input_EE, input_EI,
                          input_IE, input_II,
                          input_EA, input_IA,
                          g_AMPA_EE, g_NMDA_EE,
                          g_EI, g_II,
                          g_AMPA_IE, g_NMDA_IE,
                          g_AMPA_EA, g_NMDA_EA,
                          g_AMPA_IA, g_NMDA_IA,
                          h_NMDA_EE, h_NMDA_IE,
                          h_NMDA_EA, h_NMDA_IA,
                          I_EE, I_EI,
                          I_IE, I_II,
                          I_EA, I_IA,
                          E_syn_EE, E_syn_EI,
                          E_syn_II, E_syn_IE,
                          E_syn_EA, E_syn_IA,
                          share_AMPA_EE, share_AMPA_IE,
                          share_AMPA_EA, share_AMPA_IA,
                          tau_rise_NMDA_EE, tau_rise_NMDA_IE,
                          tau_rise_NMDA_EA, tau_rise_NMDA_IA,
                          tau_decay_AMPA_EE, tau_decay_NMDA_EE,
                          tau_decay_EI,  tau_decay_II,
                          tau_decay_AMPA_IE, tau_decay_NMDA_IE,
                          tau_decay_AMPA_EA, tau_decay_NMDA_EA,
                          tau_decay_AMPA_IA, tau_decay_NMDA_IA,
                          # noise_E, noise_I,
                          S_EE_nonzero, S_EE_values,S_EE_delay, S_EE_nzlength,
                          S_EI_nonzero, S_EI_values,S_EI_delay, S_EI_nzlength,
                          S_IE_nonzero, S_IE_values,S_IE_delay, S_IE_nzlength,
                          S_II_nonzero, S_II_values,S_II_delay, S_II_nzlength,
                          S_EA_nonzero, S_EA_values,S_EA_delay, S_EA_nzlength,
                          S_IA_nonzero, S_IA_values,S_IA_delay, S_IA_nzlength,
                          I_Aff_E, I_Aff_I,
                          spikes_E, spikes_I,
                          spike_counts_E, spike_counts_I,
                          binspikes_E, binspikes_I,
                          spikes_AE, spikes_AI,
                          mV_E, mV_I,
                          mw_E, mw_I,
                          mg_AMPA_EE, mg_NMDA_EE,
                          mg_EI,  mg_II,
                          mg_AMPA_IE, mg_NMDA_IE,
                          mg_AMPA_EA, mg_NMDA_EA,
                          mg_AMPA_IA, mg_NMDA_IA,
                          mI_EE, mI_EI,
                          mI_IE, mI_II,
                          mI_EA, mI_IA,
                          nsE, nsI,
                          nsSE, nsSI,
                          sample_E, sample_I,
                          sample_spikes_E, sample_spikes_I,
                          mean_V_E, mean_V_I,
                          mean_w_E, mean_w_I,
                          mean_g_AMPA_EE, mean_g_NMDA_EE,
                          mean_g_EI, mean_g_II,
                          mean_g_AMPA_IE, mean_g_NMDA_IE,
                          mean_g_AMPA_EA, mean_g_NMDA_EA,
                          mean_g_AMPA_IA, mean_g_NMDA_IA,
                          mean_I_EE, mean_I_EI,
                          mean_I_IE, mean_I_II,
                          mean_I_EA, mean_I_IA,
                          times, dt,
                          steps, max_delay_ints,
                          sample_idx, sample_offset,
                          sample_times, precomputed_exp,
                          min_value_exp, max_value_exp,
                          exp_delta):

    sample_spikecount_E = 0.0
    sample_spikecount_I = 0.0

    spikecount_AE = 0.0
    spikecount_AI = 0.0

    sample_count = 0

    if spikes_AE.shape[1] == 0:
        lenAE = 0
    else:
        lenAE = spikes_AE.shape[0]
    if spikes_AI.shape[1]==0:
        lenAI = 0
    else:
        lenAI = spikes_AI.shape[0]

    normalization_NMDA_EE = (tau_rise_NMDA_EE / tau_decay_NMDA_EE) ** (tau_decay_NMDA_EE /
                                                        (tau_rise_NMDA_EE - tau_decay_NMDA_EE))
    normalization_NMDA_IE = (tau_rise_NMDA_IE / tau_decay_NMDA_IE) ** (tau_decay_NMDA_IE /
                                                        (tau_rise_NMDA_IE - tau_decay_NMDA_IE))
    normalization_NMDA_EA = (tau_rise_NMDA_EA / tau_decay_NMDA_EA) ** (tau_decay_NMDA_EA /
                                                        (tau_rise_NMDA_EA - tau_decay_NMDA_EA))
    normalization_NMDA_IA = (tau_rise_NMDA_IA / tau_decay_NMDA_IA) ** (tau_decay_NMDA_IA /
                                                        (tau_rise_NMDA_IA - tau_decay_NMDA_IA))

    store_idx = 0

    for idx in range(0, steps):

        prev_idx = (idx - 1) % steps

        current_time = times[prev_idx]+dt

        if I_Aff_E.shape[1]>1:
            the_I_Aff_E = I_Aff_E[:,idx]
        else:
            the_I_Aff_E = I_Aff_E[:,0]

        if I_Aff_I.shape[1]>1:
            the_I_Aff_I = I_Aff_I[:,idx]
        else:
            the_I_Aff_I = I_Aff_I[:,0]

        syn_idx = idx % max_delay_ints

        for mx in range(N_E):

            #### g_EE #####

            curr_g_AMPA_EE = g_AMPA_EE[mx]
            curr_g_NMDA_EE = g_NMDA_EE[mx]
            curr_h_NMDA_EE = h_NMDA_EE[mx]

            add_EE = input_EE[mx, syn_idx]
            h_add_NMDA_EE = (1.0 - share_AMPA_EE) * add_EE
            g_add_AMPA_EE = share_AMPA_EE * add_EE
            input_EE[mx, syn_idx]=0.0

            dg_NMDA_EE = (-curr_g_NMDA_EE+normalization_NMDA_EE*curr_h_NMDA_EE)/tau_decay_NMDA_EE
            dg_AMPA_EE = -curr_g_AMPA_EE/tau_decay_AMPA_EE
            dh_NMDA_EE = -curr_h_NMDA_EE/tau_rise_NMDA_EE

            new_g_AMPA_EE = curr_g_AMPA_EE + dt*dg_AMPA_EE + g_add_AMPA_EE
            g_AMPA_EE[mx] = new_g_AMPA_EE
            new_g_NMDA_EE = curr_g_NMDA_EE + dt*dg_NMDA_EE
            g_NMDA_EE[mx] = new_g_NMDA_EE
            new_h_NMDA_EE = curr_h_NMDA_EE + dt*dh_NMDA_EE + h_add_NMDA_EE
            h_NMDA_EE[mx] = new_h_NMDA_EE


            ##### g_EI #####

            curr_g_EI = g_EI[mx]

            g_add_EI = input_EI[mx, syn_idx]
            input_EI[mx, syn_idx]=0.0

            dg_EI = -curr_g_EI/tau_decay_EI

            new_g_EI = curr_g_EI + dt*dg_EI + g_add_EI
            g_EI[mx] = new_g_EI


            ##### g_EA #####

            curr_g_AMPA_EA = g_AMPA_EA[mx]
            curr_g_NMDA_EA = g_NMDA_EA[mx]
            curr_h_NMDA_EA = h_NMDA_EA[mx]

            add_EA = input_EA[mx, syn_idx]
            h_add_NMDA_EA = (1.0 - share_AMPA_EA) * add_EA
            g_add_AMPA_EA = share_AMPA_EA * add_EA
            input_EA[mx, syn_idx]=0.0

            dg_NMDA_EA = (-curr_g_NMDA_EA+normalization_NMDA_EA*curr_h_NMDA_EA)/tau_decay_NMDA_EA
            dg_AMPA_EA = -curr_g_AMPA_EA/tau_decay_AMPA_EA
            dh_NMDA_EA = -curr_h_NMDA_EA/tau_rise_NMDA_EA

            new_g_AMPA_EA = curr_g_AMPA_EA + dt*dg_AMPA_EA + g_add_AMPA_EA
            g_AMPA_EA[mx] = new_g_AMPA_EA
            new_g_NMDA_EA = curr_g_NMDA_EA + dt*dg_NMDA_EA
            g_NMDA_EA[mx] = new_g_NMDA_EA
            new_h_NMDA_EA = curr_h_NMDA_EA + dt*dh_NMDA_EA + h_add_NMDA_EA
            h_NMDA_EA[mx] = new_h_NMDA_EA


            ### Currents ###

            curr_I_EE = I_EE[mx]
            curr_I_EI = I_EI[mx]
            curr_I_EA = I_EA[mx]

            I_tot_E = curr_I_EA + curr_I_EE + curr_I_EI + the_I_Aff_E[mx]


            #### Dyn Vars ####

            curr_V_E = V_E[mx]
            curr_w_E = w_E[mx]

            dw_E = (a_E*(curr_V_E - EL_E) - curr_w_E) / tau_w_E
            w_E[mx] = curr_w_E + dt*dw_E

            if refractory_E[mx] > 0:
                new_V_E = Vr_E
                V_E[mx] = new_V_E
                refractory_E[mx] = refractory_E[mx] - 1
            else:

                if DeltaT_E != 0:
                    xval = (curr_V_E - VT_E)/DeltaT_E
                    if xval < min_value_exp:
                        xval = min_value_exp
                    elif xval > max_value_exp:
                        xval = max_value_exp

                    index = int(round((xval-min_value_exp)/exp_delta))
                    exp_term = gL_E * DeltaT_E * precomputed_exp[index]
                else:
                    exp_term = 0

                dV_E = (-gL_E*(curr_V_E - EL_E) + exp_term - curr_w_E - I_tot_E) / C_E
                new_V_E = curr_V_E + dt*dV_E #+ the_noise_E[mx]

                if new_V_E >= Vth_E:
                    new_V_E = Vr_E
                    refractory_E[mx] = refr_E_int
                    binspikes_E[mx] = 1
                    w_E[mx] += b_E

                    spike_counts_E[mx] = spike_counts_E[mx] + 1

                    for n in range(S_EE_nzlength):
                        post = S_EE_nonzero[mx, n]
                        if post < 0:
                            break

                        delay = S_EE_delay[mx, n]
                        weight = S_EE_values[mx, n]
                        input_idx = idx+delay
                        input_idx = input_idx % max_delay_ints
                        input_EE[post, input_idx] += weight

                    for n in range(S_IE_nzlength):
                        post = S_IE_nonzero[mx, n]
                        if post < 0:
                            break

                        delay = S_IE_delay[mx, n]
                        weight = S_IE_values[mx, n]
                        input_idx = idx+delay
                        input_idx = input_idx % max_delay_ints
                        input_IE[post, input_idx] += weight

                V_E[mx] = new_V_E


            #### Update Currents ####

            new_I_EE = (new_g_AMPA_EE + new_g_NMDA_EE) * (new_V_E - E_syn_EE)
            I_EE[mx] = new_I_EE

            new_I_EI = new_g_EI*(new_V_E - E_syn_EI)
            I_EI[mx] = new_I_EI

            new_I_EA = (new_g_AMPA_EA + new_g_NMDA_EA) * (new_V_E - E_syn_EA)
            I_EA[mx] = new_I_EA

        for mx in range(N_I):

            #### g_IE #####

            curr_g_AMPA_IE = g_AMPA_IE[mx]
            curr_g_NMDA_IE = g_NMDA_IE[mx]
            curr_h_NMDA_IE = h_NMDA_IE[mx]

            add_IE = input_IE[mx, syn_idx]
            h_add_NMDA_IE = (1.0 - share_AMPA_IE) * add_IE
            g_add_AMPA_IE = share_AMPA_IE * add_IE
            input_IE[mx, syn_idx]=0.0

            dg_NMDA_IE = (-curr_g_NMDA_IE+normalization_NMDA_IE*curr_h_NMDA_IE)/tau_decay_NMDA_IE
            dg_AMPA_IE = -curr_g_AMPA_IE/tau_decay_AMPA_IE
            dh_NMDA_IE = -curr_h_NMDA_IE/tau_rise_NMDA_IE

            new_g_AMPA_IE = curr_g_AMPA_IE + dt*dg_AMPA_IE + g_add_AMPA_IE
            g_AMPA_IE[mx] = new_g_AMPA_IE
            new_g_NMDA_IE = curr_g_NMDA_IE + dt*dg_NMDA_IE
            g_NMDA_IE[mx] = new_g_NMDA_IE
            new_h_NMDA_IE = curr_h_NMDA_IE + dt*dh_NMDA_IE + h_add_NMDA_IE
            h_NMDA_IE[mx] = new_h_NMDA_IE


            ##### g_II #####

            curr_g_II = g_II[mx]

            g_add_II = input_II[mx, syn_idx]
            input_II[mx, syn_idx]=0.0

            dg_II = -curr_g_II/tau_decay_II

            new_g_II = curr_g_II + dt*dg_II + g_add_II
            g_II[mx] = new_g_II


            ##### g_IA #####

            curr_g_AMPA_IA = g_AMPA_IA[mx]
            curr_g_NMDA_IA = g_NMDA_IA[mx]
            curr_h_NMDA_IA = h_NMDA_IA[mx]

            add_IA = input_IA[mx, syn_idx]
            h_add_NMDA_IA = (1.0 - share_AMPA_IA) * add_IA
            g_add_AMPA_IA = share_AMPA_IA * add_IA
            input_IA[mx, syn_idx]=0.0

            dg_NMDA_IA = (-curr_g_NMDA_IA+normalization_NMDA_IA*curr_h_NMDA_IA)/tau_decay_NMDA_IA
            dg_AMPA_IA = -curr_g_AMPA_IA/tau_decay_AMPA_IA
            dh_NMDA_IA = -curr_h_NMDA_IA/tau_rise_NMDA_IA

            new_g_AMPA_IA = curr_g_AMPA_IA + dt*dg_AMPA_IA + g_add_AMPA_IA
            g_AMPA_IA[mx] = new_g_AMPA_IA
            new_g_NMDA_IA = curr_g_NMDA_IA + dt*dg_NMDA_IA
            g_NMDA_IA[mx] = new_g_NMDA_IA
            new_h_NMDA_IA = curr_h_NMDA_IA + dt*dh_NMDA_IA + h_add_NMDA_IA
            h_NMDA_IA[mx] = new_h_NMDA_IA


            ### Currents ###

            curr_I_IE = I_IE[mx]
            curr_I_II = I_II[mx]
            curr_I_IA = I_IA[mx]

            I_tot_I = curr_I_IA + curr_I_IE + curr_I_II + the_I_Aff_I[mx]


            #### Dyn Vars ####

            curr_V_I = V_I[mx]
            curr_w_I = w_I[mx]

            dw_I = (a_I*(curr_V_I - EL_I) - curr_w_I) / tau_w_I
            w_I[mx] = curr_w_I + dt*dw_I

            if refractory_I[mx] > 0:
                new_V_I = Vr_I
                V_I[mx] = new_V_I
                refractory_I[mx] = refractory_I[mx] - 1
            else:
                if DeltaT_I != 0:
                    xval = (curr_V_I - VT_I)/DeltaT_I
                    if xval < min_value_exp:
                        xval = min_value_exp
                    elif xval > max_value_exp:
                        xval = max_value_exp

                    index = int(round((xval-min_value_exp)/exp_delta))
                    exp_term = gL_I * DeltaT_I * precomputed_exp[index]
                else:
                    exp_term = 0

                dV_I = (-gL_I*(curr_V_I - EL_I) + exp_term - curr_w_I - I_tot_I) / C_I
                new_V_I = curr_V_I + dt*dV_I #+ the_noise_I[mx]

                if new_V_I >= Vth_I:
                    new_V_I = Vr_I
                    refractory_I[mx] = refr_I_int
                    binspikes_I[mx] = 1
                    w_I[mx] += b_I

                    spike_counts_I[mx] = spike_counts_I[mx] + 1

                    for n in range(S_EI_nzlength):
                        post = S_EI_nonzero[mx, n]
                        if post < 0:
                            break

                        delay = S_EI_delay[mx, n]
                        weight = S_EI_values[mx, n]
                        input_idx = idx+delay
                        input_idx = input_idx % max_delay_ints
                        input_EI[post, input_idx] += weight

                    for n in range(S_II_nzlength):
                        post = S_II_nonzero[mx, n]
                        if post < 0:
                            break

                        delay = S_II_delay[mx, n]
                        weight = S_II_values[mx, n]
                        input_idx = idx+delay
                        input_idx = input_idx % max_delay_ints
                        input_II[post, input_idx] += weight

                V_I[mx] = new_V_I


            #### Update Currents ####

            new_I_IE = (new_g_AMPA_IE + new_g_NMDA_IE) * (new_V_I - E_syn_IE)
            I_IE[mx] = new_I_IE

            new_I_II = new_g_II*(new_V_I - E_syn_II)
            I_II[mx] = new_I_II

            new_I_IA = (new_g_AMPA_IA + new_g_NMDA_IA) * (new_V_I - E_syn_IA)
            I_IA[mx] = new_I_IA


        times[idx] = current_time

        for k in range(nsSE):
            msSx = sample_spikes_E[k]
            spike = binspikes_E[msSx]
            if spike==1:
                binspikes_E[msSx]=0
                count_idx = int(sample_spikecount_E)
                spikes_E[count_idx, 0] = msSx
                spikes_E[count_idx, 1] = current_time
                sample_spikecount_E += 1.0


        for k in range(nsSI):
            msSx = sample_spikes_I[k]
            spike = binspikes_I[msSx]
            if spike==1:
                binspikes_I[msSx]=0
                count_idx = int(sample_spikecount_I)
                spikes_I[count_idx, 0] = msSx
                spikes_I[count_idx, 1] = current_time
                sample_spikecount_I += 1.0

        offset_idx = idx + sample_offset

        if offset_idx % sample_idx == 0:

            sample_times[store_idx] = times[idx]

            sample_count = sample_count +1
            float_sample_count = float(sample_count)

            for k in range(nsE):
                mTx = int(sample_E[k])
                mg_AMPA_EE[k, store_idx] = g_AMPA_EE[mTx]
                mg_NMDA_EE[k, store_idx] = g_NMDA_EE[mTx]
                mg_EI[k, store_idx] = g_EI[mTx]
                mg_AMPA_EA[k, store_idx] = g_AMPA_EA[mTx]
                mg_NMDA_EA[k, store_idx] = g_NMDA_EA[mTx]
                mI_EA[k, store_idx] = I_EA[mTx]
                mI_EE[k, store_idx] = I_EE[mTx]
                mI_EI[k, store_idx] = I_EI[mTx]
                mV_E[k, store_idx] = V_E[mTx]
                mw_E[k, store_idx] = w_E[mTx]

            for k in range(N_E):
                curr_mean_g_AMPA_EE = mean_g_AMPA_EE[k]
                mean_g_AMPA_EE[k] = curr_mean_g_AMPA_EE + \
                                    (g_AMPA_EE[k] - curr_mean_g_AMPA_EE)/float_sample_count

                curr_mean_g_NMDA_EE = mean_g_NMDA_EE[k]
                mean_g_NMDA_EE[k] = curr_mean_g_NMDA_EE + \
                                    (g_NMDA_EE[k] - curr_mean_g_NMDA_EE)/float_sample_count

                curr_mean_g_EI = mean_g_EI[k]
                mean_g_EI[k] = curr_mean_g_EI + (g_EI[k] - curr_mean_g_EI)/float_sample_count

                curr_mean_g_AMPA_EA = mean_g_AMPA_EA[k]
                mean_g_AMPA_EA[k] = curr_mean_g_AMPA_EA + \
                                    (g_AMPA_EA[k] - curr_mean_g_AMPA_EA)/float_sample_count

                curr_mean_g_NMDA_EA = mean_g_NMDA_EA[k]
                mean_g_NMDA_EA[k] = curr_mean_g_NMDA_EA + \
                                    (g_NMDA_EA[k] - curr_mean_g_NMDA_EA)/float_sample_count

                curr_mean_I_EA = mean_I_EA[k]
                mean_I_EA[k] = curr_mean_I_EA + (I_EA[k] - curr_mean_I_EA)/float_sample_count

                curr_mean_I_EE = mean_I_EE[k]
                mean_I_EE[k] = curr_mean_I_EE + (I_EE[k] - curr_mean_I_EE)/float_sample_count

                curr_mean_I_EI = mean_I_EI[k]
                mean_I_EI[k] = curr_mean_I_EI + (I_EI[k] - curr_mean_I_EI)/float_sample_count

                curr_mean_V_E = mean_V_E[k]
                mean_V_E[k] = curr_mean_V_E + (V_E[k] - curr_mean_V_E)/float_sample_count

                curr_mean_w_E = mean_w_E[k]
                mean_w_E[k] = curr_mean_w_E + (w_E[k] - curr_mean_w_E)/float_sample_count

            for k in range(nsI):
                mTx = int(sample_I[k])
                mg_AMPA_IE[k, store_idx] =  g_AMPA_IE[mTx]
                mg_NMDA_IE[k, store_idx] =  g_NMDA_IE[mTx]
                mg_II[k, store_idx] = g_II[mTx]
                mg_AMPA_IA[k, store_idx] = g_AMPA_IA[mTx]
                mg_NMDA_IA[k, store_idx] = g_NMDA_IA[mTx]
                mI_IA[k, store_idx] = I_IA[mTx]
                mI_IE[k, store_idx] = I_IE[mTx]
                mI_II[k, store_idx] = I_II[mTx]
                mV_I[k, store_idx] = V_I[mTx]
                mw_I[k, store_idx] = w_I[mTx]

            for k in range(N_I):
                curr_mean_g_AMPA_IE = mean_g_AMPA_IE[k]
                mean_g_AMPA_IE[k] = curr_mean_g_AMPA_IE + \
                                    (g_AMPA_IE[k] - curr_mean_g_AMPA_IE)/float_sample_count

                curr_mean_g_NMDA_IE = mean_g_NMDA_IE[k]
                mean_g_NMDA_IE[k] = curr_mean_g_NMDA_IE + \
                                    (g_NMDA_IE[k] - curr_mean_g_NMDA_IE)/float_sample_count

                curr_mean_g_II = mean_g_II[k]
                mean_g_II[k] = curr_mean_g_II + (g_II[k] - curr_mean_g_II)/float_sample_count

                curr_mean_g_AMPA_IA = mean_g_AMPA_IA[k]
                mean_g_AMPA_IA[k] = curr_mean_g_AMPA_IA + \
                                    (g_AMPA_IA[k] - curr_mean_g_AMPA_IA)/float_sample_count

                curr_mean_g_NMDA_IA = mean_g_NMDA_IA[k]
                mean_g_NMDA_IA[k] = curr_mean_g_NMDA_IA + \
                                    (g_NMDA_IA[k] - curr_mean_g_NMDA_IA)/float_sample_count

                curr_mean_I_IA = mean_I_IA[k]
                mean_I_IA[k] = curr_mean_I_IA + (I_IA[k] - curr_mean_I_IA)/float_sample_count

                curr_mean_I_IE = mean_I_IE[k]
                mean_I_IE[k] = curr_mean_I_IE + (I_IE[k] - curr_mean_I_IE)/float_sample_count

                curr_mean_I_II = mean_I_II[k]
                mean_I_II[k] = curr_mean_I_II + (I_II[k] - curr_mean_I_II)/float_sample_count

                curr_mean_V_I = mean_V_I[k]
                mean_V_I[k] = curr_mean_V_I + (V_I[k] - curr_mean_V_I)/float_sample_count

                curr_mean_w_I = mean_w_I[k]
                mean_w_I[k] = curr_mean_w_I + (w_I[k] - curr_mean_w_I)/float_sample_count

            store_idx += 1


        prev_time = times[prev_idx]

        while spikecount_AE < lenAE:
            count_idx = int(spikecount_AE)
            spiketime_AE = spikes_AE[count_idx, 1]

            if spiketime_AE > current_time:
                break
            else:
                spikecount_AE += 1.0

            if spiketime_AE > prev_time:
                mSAx = int(spikes_AE[count_idx, 0])

                for n in range(S_EA_nzlength):
                    post = S_EA_nonzero[mSAx, n]
                    if post < 0:
                        break

                    delay = S_EA_delay[mSAx, n]
                    weight = S_EA_values[mSAx, n]
                    input_idx = idx+delay
                    input_idx = input_idx % max_delay_ints
                    input_EA[post, input_idx] += weight

        while spikecount_AI < lenAI:
            count_idx = int(spikecount_AI)
            spiketime_AI = spikes_AI[count_idx, 1]

            if spiketime_AI > current_time:
                break
            else:
                spikecount_AI += 1.0

            if spiketime_AI > prev_time:
                mSAx = int(spikes_AI[count_idx, 0])

                for n in range(S_IA_nzlength):
                    post = S_IA_nonzero[mSAx, n]
                    if post < 0:
                        break

                    delay = S_IA_delay[mSAx, n]
                    weight = S_IA_values[mSAx, n]
                    input_idx = idx+delay
                    input_idx = input_idx % max_delay_ints
                    input_IA[post, input_idx] += weight

    pass # To be able to halt here while debugging


